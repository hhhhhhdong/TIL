# Computer Abstractions and Technology

- Progress in computer technology
  - Underpinned by **Moore's Law**
- Computers are pervasive



### Moore's Law

- In 1965, Inter's Gorden Moore predicted that the **number of transistors that can be integrated on single chip would double about every two years**

>**하나의 칩에 들어 갈수 있는 트랜지스터의 칩은 매 2년 마다 2배씩 늘어날 것이다.** 라고 예측
>2000년대 초반까지는 잘 맞았지만 그 이후로는 더 이상 지켜지지 않고있다.



### Some Basic Definitions

![image-20210830100016924](img/image-20210830100016924.png)

> 2의 배수 단위는 컴퓨터, 저장장치 쪽에서 사용
> 10의 배수 단위는 네트워크, 통신 쪽에서 사용



## Understanding Performance

- Algorithm
  - Determines number of operations executed

> operations의 수를 줄이는 것

- Programming Language, compiler, architecture
  - Determine number of machine instructions executed per operation

>실행하는 instructions(명령어) 수를 줄이는 것

- Processor and memory system
  - Determine how fast instructions are executed

> 명령어 들을 얼마나 빨리 실행 시키냐

- I/O system (including OS)
  - Determines how fast I/O operations are executed

> I/O operations를 얼마나 빨리 처리하느냐



### Eight Great Ideas

- Design for **Moore's Law**
- Use **abstraction** to simplify design
- Make the **common case fast**
- Performance via **parallelism**
- Performance via **pipelining**
- Performance via **prediction**
- **Hierarchy** of memories
- **Dependability** via redundancy



## Below Your Program

- Application software
  - Written in high-level language
- System software
  - Compiler: translates HLL code to machine code
  - Operating System: service code
    - Handling input/output
    - Managing memory and storage
    - Scheduling tasks & sharing resources
- Hardware
  - Processor, memory, I/O controllers



### Levels of Program Code

- High-level language
  - Level of abstraction closer to problem domain
  - Provides for productivity(생산성) and portability(휴대성)
- Assembly language
  - Textual representation of instructions

> 바이너리 코드, 머신코드의 텍스트 표현

- Hardware representation
  - Binary digits (bits)
  - Encoded instructions and data



## Abstractions

- Abstraction helps us deal with complexity
  - Hide lower-level detail

> 복잡한 부분을 감추고 문제를 단순화하여 쉽게 해결한다.

- instruction set architecture (ISA)
  - The hardware/software interface

> 소프트웨어는 instruction으로 구성되어 있고 하드웨어는 이 instruction을 실행한다.

- Application binary interface(ABI)
  - The ISA plus system software interface

> ABI가 같으면 다른 컴퓨터의 시스템 프로그램에서 실행이 가능하다.

- Implementation
  - The details underlying and interface

> ISA를 어떻게 실제로 구현할 것인가, 구현방법

> **소프트웨어와 하드웨어가 밀접한 관련(independency)이 없도록 만들어주는 것이 ISA.**
> 소프트웨어는 ISA에서 지원해주는 instruction을 가지고 프로그램을 만들면 되고,
> 하드웨어는 ISA에서 지원해주는 instruction을 실행하면 된다.





## Performance

- Response time (latency)
  - How long it takes to do a task

> 하나의 일을 수행하는데 얼마의 시간이 걸리냐

- Throughput
  - Total work done per unit time
    - tasks/transactions/ .... per hour

>단위 시간당 몇개의 일을 하느냐

- How are response time and throughput affected by
  - Replacing the processor with a faster version?
    - response time은 줄어들고 throughput은 증가한다.
  - Adding more processors
    - response time은 그대로이고 throughput은 증가한다.
- We'll focus on **response time** for now...



### Relative Performance

- Define Performance = 1/Execution Time
- "X is n time faster than Y"
  - ![image-20210830164706169](img/image-20210830164706169.png)
- Example: time taken to run a program
  - 10s on A, 15s on B
  - Execution Time(B) / Execution Time(A) = 15s /10s = 1.5
  - So A is 1.5 times faster than B



#### Measuring Execution Time

- Elapsed time
  - Total response time, including all aspects
    - Processing, I/O, OS overhead, idle time
  - Determines system performance
- CPU time
  - Time spent processing a given job
    - Discounts I/O time, other job's shares
  - Comprises user CPU time system CPU time
  - **Different programs are affected differently by CPU and system performance**



#### CPU Clocking

- Operation of digital hardware governed by a constant-rate clock
- ![image-20210830170200874](img/image-20210830170200874.png)
- Clock period
  - rising edge 하나와 falling edge 하나로 구성
  - 하나의 클락사이클에 걸리는 시간
- Clock frequency (rate)
  - 1초에 싸이클이 몇개 인가
- **Clock rate is inverse of clock cycle time**
  - ![image-20210830170539253](img/image-20210830170539253-16303107400281.png)



#### CPU Time

- ![image-20210830192450452](img/image-20210830192450452.png)
- Perfomance improved by
  - Reducing number of clock cycles
  - Increasing clock rate
  - **Hardware designer must often trade off clock rate against cycle count**

> clock rate을 높이면 cycle count도 같이 증가한다. 상관관계가 있다.
> 따라서, 하드웨어 디자이너들은 두개의 비율을 잘 조정해서 성능이 좋은 포인트를 찾아야 한다.



#### Instruction Count and CPI

- ![image-20210830193500211](img/image-20210830193500211.png)
- Instruction Count for a program
  - Determined by program, ISA and compiler
  - instruction count는 위의 세가지에 의해 결정된다.
- Average cycles per instruction
  - Determined by CPU hardware
  - If different instructions have different CPI
    - Average CPI affected by instruction mix
    - 프로그램마다 명령어들의 비율이 다르기 때문에 average CPI가 다를 수 있다.
- Example
  - ![image-20210830194924860](img/image-20210830194924860.png)
  - Computer A가 B보다 1.2배 빠르다.



#### CPI in More Detail

- if different instruction classes take different numbers of cycles
  - ![image-20210830195149313](img/image-20210830195149313.png)
  - 각각의 명령어들은 다른 CPI를 갖기 때문에 각각의 cCPI를 곱해주어야 한다.



















> 참고문헌
> *Computer Organization and Design, 5th Edition, by Patterson and Hennessy, 2014*
